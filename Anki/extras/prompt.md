Provide the **most optimized, production-quality, and interview-ready Rust solution** for the following DSA problem:  

### Problem:



### Typing



### Requirements:  

ðŸ”¹ **Optimal Time Complexity**  
- State the algorithm's time complexity and justify why it is optimal given the problem constraints.  

ðŸ”¹ **Optimal Space Complexity**  
- Minimize extra space usage and explain the space complexity.  

ðŸ”¹ **Rust Code Quality**  
- Use **clean, idiomatic, modular Rust code** suitable for **FAANG/MAANG interviews**.  
- Follow **ownership, borrowing, and iterator best practices**.  
- Include **realistic interview-level function signatures** (`fn solve(...) -> ...`).  
- Avoid unnecessary `unwrap()`, `expect()`, or unsafe code unless clearly justified.  
- Handle all **edge cases** thoughtfully within the code.  
- Provide **unit tests** (`#[test]`) for common and edge cases.  

ðŸ”¹ **Algorithm Explanation**  
- Describe the **core DSA concepts** used (e.g., Greedy, DP, Binary Search).  
- Explain the **algorithm design, reasoning**, and why this is the most optimal approach.  
- Discuss any **critical trade-offs** made.  
- Identify common **edge cases** and explain how they are handled.  

ðŸ”¹ **Constraints & Scalability**  
- Analyze the solution's behavior under **maximum input sizes**.  
- Confirm it passes **stress tests** without significant performance degradation.  

ðŸ”¹ **DSA Tags**  
- Suggest relevant DSA topics (e.g., Arrays, Trees, Graphs, Dynamic Programming, Sliding Window).  

ðŸ”¹ **Follow-up Enhancements (Optional)**  
- How would the solution adapt to **streaming input**, **parallelization**, or **distributed systems**?  
- What are potential **real-world applications** of this approach?  
